..
  finished: 13/16

  xx autoexception:: SignatureError
  xx autoexception:: ConnectionError
  xx autoclass:: Flow()
  xx autodata:: Out
  xx autodata:: In
  xx autoclass:: Member(flow, description, *, reset=None)
  xx autoclass:: SignatureMembers
  xx autoclass:: FlippedSignatureMembers
  .. autoclass:: Signature
  xx autoclass:: FlippedSignature
  xx autoclass:: SignatureMeta
  xx autoclass:: Interface
  xx autoclass:: FlippedInterface
  xx autofunction:: flipped
  .. autofunction:: connect
  .. autoclass:: Component

Interfaces and connections
##########################

.. py:module:: amaranth.lib.wiring

The :mod:`amaranth.lib.wiring` module provides a way to describe the interfaces between design components and connect them to each other in a reliable and convenient way.

.. testsetup::

   from amaranth import *
   from amaranth.lib import enum


Introduction
============

Overview
++++++++

This module provides four related facilities:

1. Description and construction of interface objects via :class:`Flow` (:data:`In` and :data:`Out`), :class:`Member`, and :class:`Signature`, as well as the associated container class :class:`SignatureMembers`. These classes provide the syntax used in defining components, and are also useful for introspection.
2. Flipping of signatures and interface objects via :class:`FlippedSignature` and :class:`FlippedInterface`, as well as the associated container class :class:`FlippedSignatureMembers`. This facility reduces boilerplate by adapting existing signatures and interface objects: the flip operation changes the :data:`In` data flow of a member to :data:`Out` and vice versa.
3. Connecting interface objects together via :func:`connect`. The :func:`connect` function ensures that the provided interface objects can be connected to each other, and adds the necessary :pc:`.eq()` statements to a :class:`Module`.
4. Defining reusable, self-contained components via :class:`Component`. Components are :class:`Elaboratable` objects that interact with the rest of the design through an interface specified by their signature.

To use this module, add the following imports to the beginning of the file:

.. testcode::

   from amaranth.lib import wiring
   from amaranth.lib.wiring import In, Out


Motivation
++++++++++

Consider a reusable counter with an enable input, switchable direction, configurable limit, and overflow/underflow flags. Using only the core Amaranth language and :mod:`amaranth.lib.enum`, it could be implemented as:

.. testcode::

    class BasicCounter(Elaboratable):
        def __init__(self):
            self.en  = Signal()

            self.count = Signal(8)
            self.limit = Signal.like(self.count)

            self.overflow  = Signal()

        def elaborate(self, platform):
            m = Module()

            with m.If(self.en):
                m.d.sync += self.overflow.eq(0)
                with m.If(self.count == self.limit):
                    m.d.sync += self.overflow.eq(1)
                    m.d.sync += self.count.eq(0)
                with m.Else():
                    m.d.sync += self.count.eq(self.count + 1)

            return m

Nothing in this implementation indicates the directions of its ports (:pc:`en`, :pc:`count`, :pc:`limit`, and :pc:`overflow`) in relation to other parts of the design. To understand whether the value of a port is expected to be provided externally or generated internally, it is first necessary to read the body of the :pc:`elaborate` method. If the port is not used within that method, it is not possible to determine its direction, or whether it is even meant to be connected.

The :mod:`amaranth.lib.wiring` module provides a solution for this problem: *components*. A component is an elaboratable that declares the shapes and directions of its ports in its *signature*. The example above can be rewritten to use the :class:`Component` base class (which itself inherits from :class:`Elaboratable`) to be:

.. testcode::

    class ComponentCounter(wiring.Component):
        en: In(1)

        count: Out(8)
        limit: In(8)

        overflow: Out(1)

        def elaborate(self, platform):
            m = Module()

            with m.If(self.en):
                m.d.sync += self.overflow.eq(0)
                with m.If(self.count == self.limit):
                    m.d.sync += self.overflow.eq(1)
                    m.d.sync += self.count.eq(0)
                with m.Else():
                    m.d.sync += self.count.eq(self.count + 1)

            return m

The code in the constructor *creating* the signals of the counter's interface one by one is now gone, replaced with the :term:`variable annotations <python:variable annotation>` *describing* the counter's interface. The inherited constructor, :meth:`Component.__init__`, creates the same attributes with the same values as before, and the :pc:`elaborate` method is unchanged.

The major difference between the two examples is that the :pc:`ComponentCounter` provides unambiguous answers to two questions that previously required examining the :pc:`elaborate` method:

1. Which of the Python object's attributes are ports that are intended to be connected to the rest of the design.
2. What is the direction of the flow of information through the port.

This information, aside from being clear from the source code, can now be retrieved from the :pc:`.signature` attribute, which contains an instance of the :class:`Signature` class:

.. doctest::

    >>> ComponentCounter().signature
    Signature({'count': Out(8), 'en': In(1), 'limit': In(8), 'overflow': Out(1)})

The :ref:`shapes <lang-shapes>` of the ports need not be static. The :pc:`ComponentCounter` can be made generic, with its range specified when it is constructed, by creating the signature explicitly in its constructor:

.. testcode::

    class GenericCounter(wiring.Component):
        def __init__(self, width):
            self._signature = wiring.Signature({
                "en": In(1),

                "count": Out(width),
                "limit": In(width),

                "overflow": Out(1)
            })
            super().__init__()

        @property
        def signature(self):
            return self._signature

        # The implementation of the `elaborate` method is the same.
        elaborate = ComponentCounter.elaborate

.. todo::

    Once RFC ?? is implemented, drop :pc:`@property signature`.

.. doctest::

    >>> GenericCounter(16).signature
    Signature({'count': Out(16), 'en': In(1), 'limit': In(16), 'overflow': Out(1)})

Instances of the :class:`ComponentCounter` and :class:`GenericCounter` class are two examples of *interface objects*. An interface object is a Python object of any type whose a :pc:`signature` attribute contains a :class:`Signature` with which the interface object is compliant (as determined by the :meth:`is_compliant <Signature.is_compliant>` method of the signature).

The next section introduces the concepts of directionality and connection, and discusses interface objects in more detail.


Reusable interfaces
+++++++++++++++++++

Consider a more complex example where two components are communicating with a *stream* that is using *ready/valid signaling*, where the :pc:`valid` signal indicates that the value of :pc:`data` provided by the source is meaningful, and the :pc:`ready` signal indicates that the sink has consumed the data word:

.. testcode::

    class DataProducer(wiring.Component):
        en: In(1)

        data: Out(8)
        valid: Out(1)
        ready: In(1)

        def elaborate(self, platform): ...

    class DataConsumer(wiring.Component):
        data: In(8)
        valid: In(1)
        ready: Out(1)

        # ... other ports...

        def elaborate(self, platform): ...

Data would be transferred between these components by assigning the outputs to the inputs elsewhere in the design:

.. testcode::

    m = Module()
    m.submodules.producer = producer = DataProducer()
    m.submodules.consumer = consumer = DataConsumer()

    ...

    m.d.comb += [
        consumer.data.eq(producer.data),
        consumer.valid.eq(producer.valid),
        producer.ready.eq(consumer.ready),
    ]

Although this example is short, it is already repetitive and redundant. The ports on the producer and the consumer, which must match each other for the connection to be made correctly, are described twice; and the connection itself is made in an error-prone manual way even though the signatures include all of the information required to create it.

The signature of a stream could be defined in a generic way:

.. testcode::

    class SimpleStreamSignature(wiring.Signature):
        def __init__(self, data_shape):
            super().__init__({
                "data": Out(data_shape),
                "valid": Out(1),
                "ready": In(1)
            })

        # Implementations of __eq__ and __repr__ are omitted for clarity.

.. doctest::

    >>> SimpleStreamSignature(8).members
    SignatureMembers({'data': Out(8), 'valid': Out(1), 'ready': In(1)})

A definition like this is usable, depending on the data flow direction of the members, only in the producer (as in the code above) or only in the consumer. To resolve this problem, this module introduces *flipping*: an operation that reverses the data flow direction of the members of a signature or an interface object while leaving everything else about the object intact. In Amaranth, the (non-flipped) signature definition always describes the data flow directions appropriate for a bus initiator, stream source, controller, and so on. A bus target, stream sink, peripheral, and so on would reuse the source definition by flipping it.

A signature is flipped by calling :meth:`sig.flip() <Signature.flip>`, and an interface object is flipped by calling :func:`flipped(intf) <flipped>`. These calls return instances of the :class:`FlippedSignature` and :class:`FlippedInterface` classes, respectively, which use metaprogramming to wrap another object, changing only the data flow directions of its members and forwarding all other method calls and attribute accesses to the wrapped object.

The example above can be rewritten to use this definition of a stream signature as:

.. testcode::

    class StreamProducer(wiring.Component):
        en: In(1)
        source: Out(SimpleStreamSignature(8))

        def elaborate(self, platform): ...

    class StreamConsumer(wiring.Component):
        sink: Out(SimpleStreamSignature(8).flip())

        def elaborate(self, platform): ...

    m = Module()
    m.submodules.producer = producer = StreamProducer()
    m.submodules.consumer = consumer = StreamConsumer()

The producer and the consumer reuse the same signature, relying on flipping to make the port directions complementary:

.. doctest::

    >>> producer.source.signature.members
    SignatureMembers({'data': Out(8), 'valid': Out(1), 'ready': In(1)})
    >>> producer.source.signature.members['data']
    Out(8)
    >>> consumer.sink.signature.members
    SignatureMembers({'data': Out(8), 'valid': Out(1), 'ready': In(1)}).flip()
    >>> consumer.sink.signature.members['data']
    In(8)

In the :pc:`StreamConsumer` definition above, the :pc:`sink` member has its direction flipped explicitly because the sink is a stream input; this is the case for every interface due to how port directions are defined. Since this operation is so ubiquitous, it is also performed when :pc:`In(...)` is used with a signature rather than a shape. The :pc:`StreamConsumer` definition above should normally be written as:

.. testcode::

    class StreamConsumerUsingIn(wiring.Component):
        sink: In(SimpleStreamSignature(8))

        def elaborate(self, platform): ...

The data flow directions of the ports are identical between the two definitions:

.. doctest::

    >>> consumer.sink.signature.members == StreamConsumerUsingIn().sink.signature.members
    True

If signatures are nested within each other multiple levels deep, the final port direction is determined by how many nested :pc:`In(...)` members there are. For each :pc:`In(...)` signature wrapping a port, the data flow direction of the port is flipped once:

.. doctest::

    >>> sig = wiring.Signature({"port": Out(1)})
    >>> sig.members["port"]
    Out(1)
    >>> in1 = wiring.Signature({"sig": In(sig)})
    >>> in1.members["sig"].signature.members["port"]
    In(1)
    >>> in2 = wiring.Signature({"sig": In(in1)})
    >>> in2.members["sig"].signature.members["sig"].signature.members["port"]
    Out(1)

Going back to the stream example, the producer and the consumer now communicate with one another using the same set of ports with identical shapes and complementary directions (the auxiliary :pc:`en` port being outside of the stream signature), and can be *connected* using the :func:`connect` function:

.. testcode::

    wiring.connect(m, producer.source, consumer.sink)

This function examines the signatures of the two provided interface objects, ensuring that they are exactly complementary, and then adds combinatorial :pc:`.eq()` statements to the module for each of the port pairs to form the connection. Aside from the *connectability* check, the single line above is equivalent to:

.. testcode::

    m.d.comb += [
        consumer.sink.data.eq(producer.source.data),
        consumer.sink.valid.eq(producer.source.valid),
        producer.source.ready.eq(consumer.sink.ready),
    ]

Even on the simple example of a stream signature it is clear how using the :func:`connect` function results in more concise, readable, and robust code. The difference is proportionally more pronounced with more complex signatures. When a signature is being refactored, no changes to the code that uses :func:`connect` is required.

.. todo::

   Add more sections with advanced use examples:

   * Forwarding an interface
   * Using constants in :func:`connect`
   * Gaskets


Signatures
==========

.. todo::

   Finish this section

.. autoclass:: Flow()
   :no-members:

   .. autoattribute:: Out
      :no-value:
   .. autoattribute:: In
      :no-value:
   .. automethod:: flip
   .. automethod:: __call__

.. autodata:: Out
.. autodata:: In

.. autoclass:: Member(flow, description, *, reset=None)

.. autoexception:: SignatureError

.. autoclass:: SignatureMembers
.. autoclass:: FlippedSignatureMembers
   :no-members:

   .. automethod:: flip

.. autoclass:: Signature
.. autoclass:: FlippedSignature(unflipped)
   :no-members:

   .. automethod:: flip
   .. automethod:: __getattr__
   .. automethod:: __setattr__
   .. automethod:: __delattr__

.. autoclass:: SignatureMeta


Interfaces
==========

.. todo::

   Finish this section

.. autoclass:: Interface
.. autoclass:: FlippedInterface(unflipped)

.. autofunction:: flipped


Making connections
==================

.. todo::

   Finish this section

.. autoexception:: ConnectionError

.. autofunction:: connect


Components
==========

.. todo::

   Finish this section

.. autoclass:: Component
