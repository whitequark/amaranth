Simulator
#########

.. py:module:: amaranth.sim

Testing and debugging a design using hardware is often difficult, lengthy, and costly. The :mod:`amaranth.sim` module, also known as the simulator, makes it possible to evaluate a design's functionality in an artificial environment before synthesis.


Simulating circuits
-------------------

.. testsetup::

    from amaranth import *

The following examples simulate one of the two designs below: synchronous counter running in the ``sync`` clock domain, and combinational adder. They assume familiarity with the :doc:`language guide <guide>`.

.. testcode::

    from amaranth.lib import wiring
    from amaranth.lib.wiring import In, Out

    class Counter(wiring.Component):
        en: In(1, init=1)
        count: Out(4)

        def elaborate(self, platform):
            m = Module()
            with m.If(self.en):
                m.d.sync += self.count.eq(self.count + 1)
            return m

    class Adder(wiring.Component):
        a: In(16)
        b: In(16)
        o: Out(32)

        def elaborate(self, platform):
            m = Module()
            m.d.comb += self.o.eq(self.a + self.b)
            return m


Running a simulation
++++++++++++++++++++

Simulating a design always requires the three basic steps: constructing the :abbr:`DUT (Design Under Test)`, constructing a :class:`Simulator` for it, and running the simulation with the :meth:`Simulator.run` or :meth:`Simulator.run_until` method:

.. testcode::

    from amaranth.sim import Simulator

    dut = Counter()
    sim = Simulator(dut)
    sim.run()

However, the code above neither stimulates the DUT's inputs nor measures the DUT's outputs; the :meth:`Simulator.run` method also immediately returns if no stimulus is added to the simulation. To make it useful, several changes are necessary:

* The :meth:`Simulator.add_clock` method adds a *stimulus*: a process external to the DUT that manipulates its inputs (in this case, toggles the clock of the ``sync`` domain).
* The :meth:`Simulator.run_until` method runs the simulation until a specific deadline is reached.
* The :meth:`Simulator.write_vcd` method captures the DUT's inputs, state, and outputs, and writes it to a :abbr:`VCD (Value Change Dump)` file.

.. _Surfer: https://surfer-project.org/
.. _GTKWave: https://gtkwave.sourceforge.net/

The following code simulates a design and capture the values of all the signals used in the design for each moment of simulation time:

.. testcode::

    dut = Counter()
    sim = Simulator(dut)
    sim.add_clock(1e-6) # 1 Âµs period, or 1 MHz
    with sim.write_vcd("example1.vcd"):
        sim.run_until(1e-6 * 15) # 15 periods of the clock

The captured data is saved to a :abbr:`VCD` file :file:`example1.vcd`, which can be displayed with a *waveform viewer* such as Surfer_ or GTKWave_:

.. wavedrom:: simulator/example1

    {
        "head": {"tock": 0},
        "signal": [
            {"name": "clk",   "wave": "lp.............."},
            {"name": "rst",   "wave": "l..............."},
            {"name": "en",    "wave": "h..............."},
            {"name": "count", "wave": "================",
             "data": ["0","1","2","3","4","5","6","7","8","9","10","11","12","13","14","15"]}
        ]
    }


Testing synchronous circuits
++++++++++++++++++++++++++++

To verify that the DUT works as intended during a simulation, known values are provided as the inputs, and the outputs are compared with the expected results.

This is done by adding a different type of stimulus to the simulator, a *testbench*: an :py:`async` Python function that runs concurrently with the DUT and can manipulate the signals used in the simulation. A testbench is added using the :meth:`Simulator.add_testbench` method, and receives a :class:`SimulatorContext` object through which it can interact with the simulator: inspect the value of signals using the :meth:`~SimulatorContext.get` method, change the value of signals using the :meth:`~SimulatorContext.set` method, or wait for an active edge of a :ref:`clock domain <lang-clockdomains>` using the :meth:`~SimulatorContext.tick` method.

The following example simulates a counter and verifies that it can be stopped using its :py:`en` input:

.. testcode::

    dut = Counter()

    async def tb_example2(ctx):
        await ctx.tick().repeat(5)     # wait until after the 5th edge of the `sync` domain clock
        assert ctx.get(dut.count) == 5 # verify that the counter has the expected value
        ctx.set(dut.en, False)         # deassert `dut.en`, disabling the counter
        await ctx.tick().repeat(5)     # wait until after the 10th edge of clock
        assert ctx.get(dut.count) == 5 # verify that the counter has not been incrementing
        ctx.set(dut.en, True)          # assert `dut.en`, enabling the counter again

    sim = Simulator(dut)
    sim.add_clock(1e-6)
    sim.add_testbench(tb_example2) # add a testbench; it will be executed on run() or run_until()
    with sim.write_vcd("example2.vcd"):
        sim.run_until(1e-6 * 15)

Since this circuit is synchronous, and the :meth:`~SimulatorContext.tick` method waits until after the circuit has reacted to the clock edge, the change to the :py:`en` input affects the behavior of the circuit on the next clock cycle after the change:

.. wavedrom:: simulator/example2

    {
        "head": {"tock": 0},
        "signal": [
            {"name": "clk",   "wave": "lp.............."},
            {"name": "rst",   "wave": "l..............."},
            {"name": "en",    "wave": "h....0....1....."},
            {"name": "count", "wave": "======.....=====",
             "data": ["0","1","2","3","4","5","6","7","8","9","10"]}
        ]
    }


Testing combinational circuits
++++++++++++++++++++++++++++++

A testbench that tests a combinational circuit advances simulation time using the :meth:`~SimulatorContext.delay` method instead of the :meth:`~SimulatorContext.tick` method, since the simulation does not contain a clock in this case. The :meth:`Simulator.run` method stops the simulation and returns once all testbenches finish executing.

The following example simulates an adder:

.. testcode::

    dut = Adder()

    async def tb_example3(ctx):
        await ctx.delay(1e-6)
        ctx.set(dut.a, 2)
        ctx.set(dut.b, 2)
        assert ctx.get(dut.o) == 4

        await ctx.delay(1e-6)
        ctx.set(dut.a, 1717)
        ctx.set(dut.b, 420)
        assert ctx.get(dut.o) == 2137

        await ctx.delay(2e-6)

    sim = Simulator(dut)
    sim.add_testbench(tb_example3)
    with sim.write_vcd("example3.vcd"):
        sim.run()

Since this circuit is entirely combinational, and the Amaranth simulator uses a *zero-delay model* of combinational circuits, the outputs change in the same instant as the inputs do:

.. wavedrom:: simulator/example3

    {
        "signal": [
            {"name": "a", "wave": "===.", "data": [0, 2, 1717]},
            {"name": "b", "wave": "===.", "data": [0, 2, 420]},
            {"name": "o", "wave": "===.", "data": [0, 4, 2137]}
        ]
    }


Replacing circuits with code
----------------------------

.. todo:: Write this
