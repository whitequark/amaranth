Simulator
#########

.. py:module:: amaranth.sim

The :mod:`amaranth.sim` module, also known as the simulator, makes it possible to evaluate a design's functionality in a virtual environment before it is implemented in hardware.

.. todo::

    - Finish reference documentation
    - Update memory documentation with explanation of how to simulate memories
    - Move all the docstrings in this document to be proper docstrings (incl. add ``get``/``set`` to ``SimulatorContext``)
    - Check what happens when a testbench encounters a glitch and add a test
    - Raise :class:`NameError` rather than :class:`KeyError` in :py:`tick` if domain is not found


Simulating circuits
-------------------

.. testsetup::

    from amaranth import *

The following examples simulate one of the two designs below: synchronous counter running in the ``sync`` clock domain, and combinational adder. They assume familiarity with the :doc:`language guide <guide>`.

.. testcode::

    from amaranth.lib import wiring
    from amaranth.lib.wiring import In, Out

    class Counter(wiring.Component):
        en: In(1, init=1)
        count: Out(4)

        def elaborate(self, platform):
            m = Module()
            with m.If(self.en):
                m.d.sync += self.count.eq(self.count + 1)
            return m

    class Adder(wiring.Component):
        a: In(16)
        b: In(16)
        o: Out(17)

        def elaborate(self, platform):
            m = Module()
            m.d.comb += self.o.eq(self.a + self.b)
            return m


Running a simulation
++++++++++++++++++++

Simulating a design always requires the three basic steps: constructing the :abbr:`DUT (Design Under Test)`, constructing a :class:`Simulator` for it, and running the simulation with the :meth:`Simulator.run` or :meth:`Simulator.run_until` method:

.. testcode::

    from amaranth.sim import Simulator

    dut = Counter()
    sim = Simulator(dut)
    sim.run()

However, the code above neither stimulates the DUT's inputs nor measures the DUT's outputs; the :meth:`Simulator.run` method also immediately returns if no stimulus is added to the simulation. To make it useful, several changes are necessary:

* The :meth:`Simulator.add_clock` method adds a *stimulus*: a process external to the DUT that manipulates its inputs (in this case, toggles the clock of the ``sync`` domain).
* The :meth:`Simulator.run_until` method runs the simulation until a specific deadline is reached.
* The :meth:`Simulator.write_vcd` method captures the DUT's inputs, state, and outputs, and writes it to a :abbr:`VCD (Value Change Dump)` file.

.. _Surfer: https://surfer-project.org/
.. _GTKWave: https://gtkwave.sourceforge.net/

The following code simulates a design and capture the values of all the signals used in the design for each moment of simulation time:

.. testcode::

    dut = Counter()
    sim = Simulator(dut)
    sim.add_clock(1e-6) # 1 µs period, or 1 MHz
    with sim.write_vcd("example1.vcd"):
        sim.run_until(1e-6 * 15) # 15 periods of the clock

The captured data is saved to a :abbr:`VCD` file :file:`example1.vcd`, which can be displayed with a *waveform viewer* such as Surfer_ or GTKWave_:

.. wavedrom:: simulator/example1

    {
        "head": {"tock": 0},
        "signal": [
            {"name": "clk",   "wave": "lp.............."},
            {"name": "rst",   "wave": "l..............."},
            {"name": "en",    "wave": "h..............."},
            {"name": "count", "wave": "================",
             "data": ["0","1","2","3","4","5","6","7","8","9","10","11","12","13","14","15"]}
        ]
    }


Testing synchronous circuits
++++++++++++++++++++++++++++

To verify that the DUT works as intended during a simulation, known values are provided as the inputs, and the outputs are compared with the expected results.

This is done by adding a different type of stimulus to the simulator, a *testbench*: an :py:`async` Python function that runs concurrently with the DUT and can manipulate the signals used in the simulation. A testbench is added using the :meth:`Simulator.add_testbench` method, and receives a :class:`SimulatorContext` object through which it can interact with the simulator: inspect the value of signals using the :meth:`ctx.get() <SimulatorContext.get>` method, change the value of signals using the :meth:`ctx.set() <SimulatorContext.set>` method, or wait for an active edge of a :ref:`clock domain <lang-clockdomains>` using the :meth:`ctx.tick() <SimulatorContext.tick>` method.

The following example simulates a counter and verifies that it can be stopped using its :py:`en` input:

.. testcode::

    dut = Counter()

    async def testbench_example2(ctx):
        await ctx.tick().repeat(5)     # wait until after the 5th edge of the `sync` domain clock
        assert ctx.get(dut.count) == 5 # verify that the counter has the expected value
        ctx.set(dut.en, False)         # deassert `dut.en`, disabling the counter
        await ctx.tick().repeat(5)     # wait until after the 10th edge of clock
        assert ctx.get(dut.count) == 5 # verify that the counter has not been incrementing
        ctx.set(dut.en, True)          # assert `dut.en`, enabling the counter again

    sim = Simulator(dut)
    sim.add_clock(1e-6)
    sim.add_testbench(testbench_example2) # add the testbench; run_until() calls the function
    with sim.write_vcd("example2.vcd"):
        sim.run_until(1e-6 * 15)

Since this circuit is synchronous, and the :meth:`ctx.tick() <SimulatorContext.tick>` method waits until after the circuit has reacted to the clock edge, the change to the :py:`en` input affects the behavior of the circuit on the next clock cycle after the change:

.. wavedrom:: simulator/example2

    {
        "head": {"tock": 0},
        "signal": [
            {"name": "clk",   "wave": "lp.............."},
            {"name": "rst",   "wave": "l..............."},
            {"name": "en",    "wave": "h....0....1....."},
            {"name": "count", "wave": "======.....=====",
             "data": ["0","1","2","3","4","5","6","7","8","9","10"]}
        ]
    }


Testing combinational circuits
++++++++++++++++++++++++++++++

A testbench that tests a combinational circuit advances simulation time using the :meth:`ctx.delay() <SimulatorContext.delay>` method instead of the :meth:`ctx.tick() <SimulatorContext.tick>` method, since the simulation does not contain a clock in this case. The :meth:`Simulator.run` method stops the simulation and returns once all testbenches finish executing.

The following example simulates an adder:

.. testcode::

    dut = Adder()

    async def testbench_example3(ctx):
        await ctx.delay(1e-6)
        ctx.set(dut.a, 2)
        ctx.set(dut.b, 2)
        assert ctx.get(dut.o) == 4

        await ctx.delay(1e-6)
        ctx.set(dut.a, 1717)
        ctx.set(dut.b, 420)
        assert ctx.get(dut.o) == 2137

        await ctx.delay(2e-6)

    sim = Simulator(dut)
    sim.add_testbench(testbench_example3)
    with sim.write_vcd("example3.vcd"):
        sim.run()

Since this circuit is entirely combinational, and the Amaranth simulator uses a *zero-delay model* of combinational circuits, the outputs change in the same instant as the inputs do:

.. wavedrom:: simulator/example3

    {
        "signal": [
            {"name": "a", "wave": "===.", "data": [0, 2, 1717]},
            {"name": "b", "wave": "===.", "data": [0, 2, 420]},
            {"name": "o", "wave": "===.", "data": [0, 4, 2137]}
        ]
    }


Replacing circuits with code
----------------------------

.. note::

    This section describes an advanced technique that is not commonly used. If you are first learning how to use the simulator, you can skip it.

During simulation, it is possible to replace an Amaranth circuit with the equivalent Python code. This can be used to improve simulation performance, or to avoid reimplementing complex Python algorithms in Amaranth if they do not need to be synthesized.

This is done by adding a *process* to the simulator: an :py:`async` Python function that runs as an integral part of the simulation, simultaneously with the DUT. A process is added using the :meth:`Simulator.add_process` method, and receives a :class:`SimulatorContext` object through which it can interact with the simulator. A process is conceptually similar to a testbench but differs from it in two important ways:

* Testbenches run in a well-defined order (from first to last in the order they were added, yielding control only at :py:`await` points) and cannot observe inconsistent intermediate states of a design, but processes run in an undefined order while the design is converging after a change to its inputs.
* In a process, it is not possible to inspect the value of a signal using the :meth:`ctx.get() <SimulatorContext.get>` method, which guarantees that inconsistent intermediate states of a design cannot be observed by a process either.

A process communicates with the rest of the design in the same way an elaboratable would: through :class:`Signal`\ s.


Replacing synchronous circuits
++++++++++++++++++++++++++++++

Processes cannot inspect values of signals using the :meth:`ctx.get() <SimulatorContext.get>` method. Instead, values of signals in a synchronous process are sampled at each active edge of the clock domain (or, for domains with asynchronous reset, at the assertion of the reset signal) using the :meth:`ctx.tick() <SimulatorContext.tick>` method.

The following code replaces the :py:`Counter` elaboratable with the equivalent Python code in a process, and uses a testbench to verify its correct operation:

.. testcode::

    m = Module()
    m.domains.sync = cd_sync = ClockDomain()
    en = Signal(init=1)
    count = Signal(4)

    async def process_example4(ctx):
        count_value = 0 # initialize counter to 0
        async for clk_edge, rst_value, en_value in ctx.tick().sample(en):
            if rst_value: # can be asserted with or without clk_edge
                count_value = 0 # re-initialize counter
            elif clk_edge and en_value:
                count_value += 1 # advance the counter
                ctx.set(count, count_value) # publish its value to the simulation

    async def testbench_example4(ctx):
        await ctx.tick().repeat(5)
        assert ctx.get(count) == 5
        ctx.set(en, False)
        await ctx.tick().repeat(5)
        assert ctx.get(count) == 5
        ctx.set(en, True)

    sim = Simulator(m)
    sim.add_clock(1e-6)
    sim.add_process(process_example4)
    sim.add_testbench(testbench_example4)
    with sim.write_vcd("example4.vcd", traces=(cd_sync.clk, cd_sync.rst, en, count)):
        sim.run()

Unless it is instructed otherwise, the :meth:`Simulator.write_vcd` method only captures values of signals that appear in the circuit provided to the simulator when it is created. The :py:`en` and :py:`count` signals do not, and are added explicitly using the :py:`traces` argument so that they will appear in the VCD file.


Replacing combinational circuits
++++++++++++++++++++++++++++++++

Values of signals in a combinational process are sampled anytime they change using the :meth:`ctx.changed() <SimulatorContext.changed>` method.

The following code replaces the :py:`Adder` elaboratable with the equivalent Python code in a process, and uses a testbench to verify its correct operation:

.. testcode::

    m = Module()
    a = Signal(16)
    b = Signal(16)
    o = Signal(17)

    async def process_example5(ctx):
        async for a_value, b_value in ctx.changed(a, b):
            ctx.set(o, a_value + b_value)

    async def testbench_example5(ctx):
        await ctx.delay(1e-6)
        ctx.set(a, 2)
        ctx.set(b, 2)
        assert ctx.get(o) == 4

        await ctx.delay(1e-6)
        ctx.set(a, 1717)
        ctx.set(b, 420)
        assert ctx.get(o) == 2137

        await ctx.delay(2e-6)

    sim = Simulator(m)
    sim.add_process(process_example5)
    sim.add_testbench(testbench_example5)
    with sim.write_vcd("example5.vcd", traces=[a, b, o]):
        sim.run()


Reference
---------

.. autoclass:: Simulator


..
    The simulator contexts have a complex interface that resides in a private module. As such they are documented in this file instead of docstrings being used.

.. class:: SimulatorContext(...)

    Simulator context.

    Simulator processes and testbenches are :py:`async` Python functions that interact with the simulation using the only argument they receive: the *context*. Using a context, it is possible to sample or update signals and wait for events to occur in the simulation.

    The context has two kinds of methods: :py:`async` methods and non-:py:`async` methods. Calling an :py:`async` method may cause the caller to be preempted (be paused such that another process or testbench can execute), while calling non-:py:`async` methods never causes that.

    .. method:: get(expr)

        Sample the value of an expression.

        The behavior of this method depends on the type of :py:`expr`:

        - If it is a :class:`~.hdl.ValueCastable` whose shape is a :class:`~.hdl.ShapeCastable`, its numeric value is converted to a higher-level representation using :meth:`~.hdl.ShapeCastable.from_bits` and then returned.
        - If it is a :class:`~.hdl.Value` or a :class:`~.hdl.ValueCastable` whose shape is a :class:`~.hdl.Shape`, the numeric value is returned as an :class:`int`.

        This method is only available in testbenches.

        :raises:
            :exc:`TypeError` – If the caller is a process.

    .. method:: set(expr, value)

        Update the value of an expression.

        The behavior of this method depends on the type of :py:`expr`:

        - If it is a :class:`~.hdl.ValueCastable` whose shape is a :class:`~.hdl.ShapeCastable`, :py:`value` is converted to a numeric representation using :meth:`~.hdl.ShapeCastable.const` and then assigned.
        - If it is a :class:`~.hdl.Value` or a :class:`~.hdl.ValueCastable` whose shape is a :class:`~.hdl.Shape`, :py:`value` is assigned as-is.

        This method is available in both processes and testbenches.

        When used in a testbench, it returns only after the change propagates through the simulated circuits, and may cause processes to be executed if they were waiting, directly or indirectly, for the signals in :py:`expr` to change. In any case, the calling testbench resumes executing afterwards.

    .. method:: critical()

        Context manager that temporarily makes the caller critical.

        Testbenches and processes may be *background* or *critical*, where critical ones prevent :meth:`Simulator.run` from finishing. Processes are always created background, while testbenches are created critical by default, but may also be created background. This context manager makes the caller critical for the span of the :py:`with` statement.

        This may be useful in cases where an operation (for example, a bus transaction) takes multiple clock cycles to complete, and must be completed after starting, but the testbench or process performing it never finishes, always waiting for the next operation to arrive. In this case, the caller would elevate itself to become critical only for the duration of the operation itself using this context manager, for example: ::

            async def testbench_bus_transaction(ctx):
                # On every cycle, check whether the bus has an active transaction...
                async for clk_edge, rst_value, bus_active_value in ctx.tick().sample(bus.active):
                    if bus_active_value: # ... if it does...
                        with ctx.critical(): # ... make this testbench critical...
                            addr_value = ctx.get(bus.r_addr)
                            ctx.set(bus.r_data, ...) # ... perform the access...
                            await ctx.tick()
                            ctx.set(bus.done, 1)
                            await ctx.tick()
                            ctx.set(bus.done, 0) # ... and complete the transaction later.
                        # The `run()` method could return at this point, but not before.

    .. method:: tick(domain, *, context=None)
        :async:

        Wait until an active clock edge or an asynchronous reset occurs.

        This method returns a :class:`TickTrigger` object that, when awaited, pauses the execution of the calling process or testbench until the active edge of the clock, or the asynchronous reset (if applicable), occurs. This trigger captures two values, :py:`clk_edge` and :py:`rst_value`. If the active edge of the clock has occurred when the wait has completed, :py:`clk_edge` is :py:`True`, otherwise it is :py:`False`. If the asynchronous reset has occurred, or the active edge of the clock has occurred while the synchronous reset has been asserted, :py:`rst_value` is :py:`True`, otherwise it is :py:`False`. The returned object may be used to repeatedly wait for one of these events until a condition to be satisfied and/or until the event happens a specific number of times.

        The :py:`domain` may be either a :class:`ClockDomain` object or a :class:`str`. If it is a :class:`str`, a clock domain with this name is looked up in the elaboratable :py:`context`, or in :py:`toplevel` if :py:`context` is not provided.

        .. note::

            The exact behavior of :py:`rst_value` differs depending on whether :py:`domain` uses synchronous or asynchronous reset; in both cases it is :py:`True` if and only if the domain reset has been asserted. Reusable processes and testbenches, as well as their building blocks, should handle both cases.

        :raises:
            - :exc:`ValueError` – If :py:`domain` is :py:`"comb"`.
            - :exc:`ValueError` – If :py:`domain` is a :class:`~.hdl.ClockDomain` and :py:`context` is provided and not :py:`None`.
            - :exc:`ValueError` – If :py:`context` is an elaboratable that is not a direct or indirect submodule of :py:`toplevel`.
            - :exc:`NameError` – If :py:`domain` is a :class:`str`, but there is no clock domain with this name in :py:`context` or :py:`toplevel`.

    .. method:: delay(interval)
        :async:

        Wait until a time interval has elapsed.

        This method returns a :class:`TriggerCombination` object that, when awaited, pauses the execution of the calling process or testbench by :py:`interval` seconds. The value captured by this trigger is :py:`True` if the delay has expired when the wait has completed, and :py:`False` otherwise. The returned object may be used to wait for multiple events.

        The :py:`interval` may be zero, in which case the caller will be scheduled for execution immediately after all of the processes and testbenches scheduled for the current time step finish executing. In other words, if a call to :meth:`Simulator.advance` schedules a process or testbench and it performs :py:`await ctx.delay(0)`, this process or testbench will continue execution only during the next call to :meth:`Simulator.advance`.

        .. note::

            Although the behavior of :py:`await ctx.delay(0)` is well-defined, it may make waveforms difficult to understand and simulations hard to reason about.

        :raises:
            :exc:`ValueError` – If :py:`delay` is negative.

    .. method:: changed(*signals)
        :async:

        Asynchronously wait until one of the signals change.

        This method returns a :class:`TriggerCombination` object that, when awaited, pauses the execution of the calling process or testbench until any of the :py:`signals` change. The values captured by this trigger are the values of :py:`signals` at the time the wait has completed. The returned object may be used to wait for multiple events.

        .. warning::

            The simulation may produce *glitches*: transient changes to signals (e.g. from 0 to 1 and back to 0) during combinational propagation that are invisible in testbenches or waveform captures. Glitches will wake up **both processes and testbenches** that use this method to wait for a signal to change, and both processes and testbenches must be prepared to handle such spurious wakeups. The presence, count, and sequence in which glitches occur may also vary between simulation runs.

            Testbenches that wait for a signal to change using an :py:`async for` loop will crash with a :exc:`BrokenTrigger` exception if they encounter a glitch. In contrast, processes will observe all of the transient values of the signal.

    .. method:: edge(signal, polarity)
        :async:

        Asynchronously wait until a low-to-high or high-to-low transition of a signal occurs.

        This method returns a :class:`TriggerCombination` object that, when awaited, pauses the execition of the calling process or testbench until the value of :py:`signal` (a single-bit signal or a single-bit slice of a signal) changes from :py:`not polarity` to :py:`polarity`. The value captured by this trigger is :py:`True` if the relevant transition of occurred at the time the wait has completed, and :py:`False` otherwise. The returned object may be used to wait for multiple events.

        .. warning::

            In most cases, this method should not be used to wait for a status signal to be asserted or deasserted in a testbench because it is likely to introduce a race condition. Instead, use :py:`await ctx.tick().until(signal == polarity)` whenever a suitable clock domain is available.

        :raises:
            - :exc:`TypeError` – If :py:`signal` is neither a single-bit :class:`Signal` nor a single-bit slice of a :class:`Signal`.
            - :exc:`TypeError` – If the shape of :py:`signal` is a :class:`ShapeCastable`.
            - :exc:`ValueError` – If :py:`polarity` is neither 0 nor 1.

    .. method:: posedge(signal)
        :async:

        Asynchronously wait until a signal is asserted.

        Equivalent to :meth:`edge(signal, 1) <edge>`.

    .. method:: negedge(signal)
        :async:

        Asynchronously wait until a signal is deasserted.

        Equivalent to :meth:`edge(signal, 0) <edge>`.


.. autoexception:: BrokenTrigger


.. autoexception:: DomainReset


.. class:: TickTrigger(...)

    A trigger that wakes up the caller when a clock domain is clocked or asynchronously reset.

    .. todo:: write this, async goes here

    .. method:: sample(*exprs)
        :async:

        Sample signals when this trigger is activated.

        This method returns a new :class:`TickTrigger` object. When awaited, this object returns, in addition to the values that would be otherwise returned by :py:`await trigger`, the values of :py:`exprs` at exactly the moment at which the active clock edge, or the asynchronous reset (if applicable), has occurred.

        Combining :meth:`~SimulatorContext.tick` with :meth:`sample` can be used to capture the state of a circuit after the active clock edge, but before propagation of signal values that have been updated by that clock edge: ::

            async for clk_edge, rst_value, in_a_value, in_b_value in \
                    ctx.tick().sample(in_a, in_b):
                ...

        Chaining calls to :meth:`sample` has the same effect as a single call with the combined list of arguments: ::

            async for clk_edge, rst_value, in_a_value, in_b_value in \
                    ctx.tick().sample(in_a).sample(in_b):
                ...

        .. note::

            Chaining calls to this method is useful for composing behavior. The following (simplified for clarity) implementation of :meth:`until` takes advantage of it by first appending :py:`condition` to the end of the list of captured expressions and then removing its value from the end of the list of their values: ::

                async def until(trigger, condition):
                    async for clk_edge, rst_value, *values, done in await trigger.sample(condition):
                        if done:
                            return values

    .. method:: until(condition)
        :async:

        Repeat this trigger until a condition is met.

        This method awaits this trigger at least once, and returns a :class:`tuple` of the values that are :meth:`sample`\ d when :py:`condition` evaluates to a non-zero value. Values sampled during previous repeats are discarded.

        Awaiting a :py:`trigger` returns values indicating the state of the clock and reset signals, while awaiting :py:`trigger.until(...)` does not:

        .. code::

            while True:
                clk_edge, rst_value, *values, is_done_value = await trigger.sample(is_done) # never raises
                if is_done_value:
                    break
            # `values` may be used after the loop finishes

        .. code::

            values = await trigger.until(is_done) # may raise `DomainReset`

        :raises:
            - :exc:`TypeError` – If the shape of :py:`condition` is a :class:`ShapeCastable`.
            - :exc:`DomainReset` – If the clock domain has been synchronously or asynchronously reset during the wait.

    .. method:: repeat(count)
        :async:

        Repeat this trigger a specific number of times.

        This method awaits this trigger at least once, and returns a :class:`tuple` of the values that are :meth:`sample`\ d during the last repeat. Values sampled during previous repeats are discarded.

        Awaiting a :py:`trigger` returns values indicating the state of the clock and reset signals, while awaiting :py:`trigger.repeat(...)` does not:

        .. code::

            for _ in range(3):
                clk_edge, rst_value, *values = await trigger # never raises
            # `values` may be used after the loop finishes

        .. code::

            values = await trigger.repeat(3) # may raise `DomainReset`

        :raises:
            - :exc:`ValueError` – If :py:`count` is less than 1.
            - :exc:`DomainReset` – If the clock domain has been synchronously or asynchronously reset during the wait.


.. class:: TriggerCombination(...)

    A set of triggers, each of which will wake up the caller.

    .. todo:: write this, await async for goes here

    .. method:: sample(*exprs)
        :async:

        Sample signals when this trigger is activated.

        This method returns a new :class:`TriggerCombination` object. When awaited, this object returns, in addition to the values that would be otherwise returned by :py:`await trigger`, the values of :py:`exprs` at exactly the moment at which the shortest delay expired or a signal has changed state.

        Combining :meth:`~SimulatorContext.delay`, :meth:`~SimulatorContext.changed`, or :meth:`~SimulatorContext.edge` with :meth:`sample` can be used to capture the state of a circuit at the time of the event: ::

            async for arst_edge, delay_expired, in_a_value, in_b_value in \
                    ctx.posedge(arst).delay(1e-3).sample(in_a, in_b):
                ...

        Chaining calls to :meth:`sample` has the same effect as a single call with the combined list of arguments: ::

            async for arst_edge, delay_expired, in_a_value, in_b_value in \
                    ctx.posedge(arst).delay(1e-3).sample(in_a).sample(in_b):
                ...

        .. note::

            Chaining calls to this method is useful for composing behavior. See the documentation for :meth:`TickTrigger.sample` for a detailed example.

    .. method:: delay(interval)
        :async:

        Add a delay trigger to the set of triggers.

        The behavior of the added trigger described in :meth:`SimulatorContext.delay`.

    .. method:: changed(*signals)
        :async:

        Add a signal change trigger to the set of triggers.

        The behavior of the added trigger described in :meth:`SimulatorContext.changed`.

    .. method:: edge(signal, polarity)
        :async:

        Add a low-to-high or high-to-low transition trigger to the set of triggers.

        The behavior of the added trigger described in :meth:`SimulatorContext.edge`.

    .. method:: posedge(*signals)
        :async:

        Add a low-to-high transition to the set of triggers.

        The behavior of the added trigger described in :meth:`SimulatorContext.posedge`.

    .. method:: negedge(*signals)
        :async:

        Add a high-to-low transition to the set of triggers.

        The behavior of the added trigger described in :meth:`SimulatorContext.negedge`.
